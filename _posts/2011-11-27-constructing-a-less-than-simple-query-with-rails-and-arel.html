---
layout: post
status: publish
published: true
title: Constructing A Less Than Simple Query With Rails And ARel
author:
  display_name: dontangg
  login: dontangg
  email: robert.don.wilson@gmail.com
  url: ''
author_login: dontangg
author_email: robert.don.wilson@gmail.com
excerpt: "I say the query is less than simple because it's not really complicated
  either. &nbsp;In my little application, I really only have one query that is like
  this and this is the one. &nbsp;This is the query that I wanted to run:\r\n\r\n[sourcecode
  language=\"sql\"]\r\nSELECT \"envelopes\".*, COALESCE(SUM(\"transactions\".\"amount\"),
  0) AS total_amount\r\nFROM \"envelopes\" LEFT OUTER JOIN \"transactions\" ON \"envelopes\".\"id\"
  = \"transactions\".\"envelope_id\"\r\nWHERE \"envelopes\".\"user_id\" = 3\r\nGROUP
  BY \"envelopes\".\"id\", \"envelopes\".\"name\", \"envelopes\".\"user_id\", \"envelopes\".\"income\",
  \"envelopes\".\"unassigned\", \"envelopes\".\"parent_envelope_id\", \"envelopes\".\"expense\",
  \"envelopes\".\"created_at\", \"envelopes\".\"updated_at\"\r\nORDER BY \"envelopes\".\"name\"\r\n[&#47;sourcecode]"
wordpress_id: 246
wordpress_url: http://blog.donwilson.net/?p=246
date: '2011-11-27 00:38:31 -0700'
date_gmt: '2011-11-27 07:38:31 -0700'
categories:
- Programming
tags:
- Ruby
- Rails
comments:
- id: 76
  author: David Simon
  author_email: david.mike.simon@gmail.com
  author_url: ''
  date: '2012-02-20 22:14:00 -0700'
  date_gmt: '2012-02-21 05:14:00 -0700'
  content: "Oh man, you saved me hours with this. I could not for the life of me figure
    out how to get Arel to run an arbitrary SQL function.\r\n\r\nWith careful use
    of SqlLiteral and Node#to_sql, you can get even more into SQL's when necessary
    guts without compromising Arel's handy composability. For example, I needed to
    get a count of all the rows that pass a given predicate:\r\n \r\n\r\nn = products_table[:price].gt(10.00)\r\n\r\ndef
    predicate_count(pred)\r\n  Arel::Nodes::SqlLiteral.new(\r\n    \"CASE WHEN #{n.to_sql}
    THEN 1 ELSE NULL END\"\r\n  ).count\r\nend\r\n\r\n\r\nSo now I can get the number
    of expensive items in each category like so:\r\n\r\n\r\nproducts_table.project(\r\n
    \ products_table[:category],\r\n  predicate_count(products_table[:price].gt(10.00))\r\n).group(products_table[:category]\r\n\r\n\r\nIf
    I were feeling more ambitious I would release some kind of monkey-patchery gem
    that builds this stuff into Arel. It's weird that there are so many universally
    supported and commonly used SQL idioms that Arel doesn't recognize, concatenation
    and conditionals in particular."
- id: 77
  author: David Simon
  author_email: david.mike.simon@gmail.com
  author_url: ''
  date: '2012-02-20 22:15:27 -0700'
  date_gmt: '2012-02-21 05:15:27 -0700'
  content: Argh, that posted before I was finished with it. In my code, please ignore
    that first "n =" line, and replace "n.to_sql" with "pred.to_sql" in the function
    body.
- id: 609
  author: Kannan
  author_email: kannanhudson@gmail.com
  author_url: http://www.kannansv.in
  date: '2013-10-01 06:15:42 -0600'
  date_gmt: '2013-10-01 12:15:42 -0600'
  content: It's easy to understand  about Arel.  Thank you!
---
<p>I say the query is less than simple because it's not really complicated either. &nbsp;In my little application, I really only have one query that is like this and this is the one. &nbsp;This is the query that I wanted to run:</p>
<p>[sourcecode language="sql"]<br />
SELECT "envelopes".*, COALESCE(SUM("transactions"."amount"), 0) AS total_amount<br />
FROM "envelopes" LEFT OUTER JOIN "transactions" ON "envelopes"."id" = "transactions"."envelope_id"<br />
WHERE "envelopes"."user_id" = 3<br />
GROUP BY "envelopes"."id", "envelopes"."name", "envelopes"."user_id", "envelopes"."income", "envelopes"."unassigned", "envelopes"."parent_envelope_id", "envelopes"."expense", "envelopes"."created_at", "envelopes"."updated_at"<br />
ORDER BY "envelopes"."name"<br />
[&#47;sourcecode]<a id="more"></a><a id="more-246"></a></p>
<p>Don't try to read that. It looks more complicated than it is because it's long. In my application, users have envelopes and those envelopes have transactions and transactions have a cash amount. Basically, I'm getting all the envelopes owned by a user and the total amount for each envelope (a SUM of all the amounts of all the transactions in those envelopes). This query is definitely more complicated than the typical query, but as far as SQL goes, it's still pretty simple. Here were my priorities for this:</p>
<ul>
<li>One query that gets the job done. Not more than one query.<&#47;li>
<li>Use ActiveRecord to consume the query. I still wanted to work with Envelope objects even though I also wanted the total.<&#47;li>
<li>No extensive use of strings because I use SQLite3 for development and Postgres for production. There are differences in syntax (quoting, etc.) that I don't want to worry about.<&#47;li><br />
<&#47;ul></p>
<p>My first attempt was just creating a SQL string to see if I could just use the <code>find_by_sql<&#47;code> method to get all the data back and still access the total.</p>
<p>[sourcecode language="ruby"]<br />
sql = 'SELECT "envelopes".*, COALESCE(SUM("transactions"."amount"), 0) AS total_amount FROM "envelopes" LEFT OUTER JOIN "transactions" ON "envelopes"."id" = "transactions"."envelope_id" WHERE "envelopes"."user_id" = 3 GROUP BY "envelopes"."id", "envelopes"."name", "envelopes"."user_id", "envelopes"."income", "envelopes"."unassigned", "envelopes"."parent_envelope_id", "envelopes"."expense", "envelopes"."created_at", "envelopes"."updated_at" ORDER BY "envelopes"."name"'<br />
envelopes = Envelope.find_by_sql(sql)<br />
[&#47;sourcecode]</p>
<p>This worked great. It turns out that all the columns returned were accessible. For example, when I have an envelope populated with data from this query, I can just say <code>envelope.total_amount<&#47;code> to get the value and it doesn't do any other queries even though <code>total_amount<&#47;code> isn't a column in the envelopes table. To make this access even nicer, I added a method to my Envelope class.</p>
<p>[sourcecode language="ruby"]<br />
def total_amount<br />
  @total_amount ||= read_attribute(:total_amount) || transactions.sum(:amount)<br />
end<br />
[&#47;sourcecode]</p>
<p><code>read_attribute<&#47;code> is what is called behind the scenes whenever you access your data. I call that since it won't get to <code>method_missing<&#47;code> anymore when I try to access <code>total_amount<&#47;code>. If that value wasn't provided in the query that populated this envelope object, then I get it by summing all the transactions' amounts. Either way, I memoize the value in an instance variable. If the instance variable is set, it will return it's value before doing anything else. Using a tip found on <a href='http:&#47;&#47;weblog.jamisbuck.org&#47;2007&#47;1&#47;8&#47;watching-activerecord-do-it-s-thing'>Jamis Buck's blog<&#47;a> was very helpful in testing this to make sure it was working. To see all the SQL queries that are run, you can just run <code>ActiveRecord::Base.logger = Logger.new(STDOUT)<&#47;code> in the Rails console.</p>
<p>This solution is nice because it solves the first two concerns I had. However, it isn't very portable. The whole query is just a string. So I looked through the Rails documentation to see if it was possible to build this query just using the Active Record Query Interface. The things that I was having a hard time figuring out how to do was getting all of the envelopes columns while summing the transactions as well as getting an outer join in the query. If there aren't any transactions, I still want the envelope to return (inner join doesn't work). I could get it to do an outer join if I used the <code>includes<&#47;code> method and I put something in the <code>where<&#47;code> that required the included table. Anyways... I decided to just build the SQL string using ARel and just plop it into the <code>find_by_sql<&#47;code> method. After a lot of digging through ARel documentation and looking through the source code, I finally found a way to do it. Here it is:</p>
<p>[sourcecode language="ruby"]<br />
et = Envelope.arel_table<br />
tt = Transaction.arel_table</p>
<p>envelopes_columns = Envelope.column_names.map {|column_name| et[column_name.to_sym] }</p>
<p>sum_function = Arel::Nodes::NamedFunction.new('SUM', [tt[:amount]])<br />
aggregation = Arel::Nodes::NamedFunction.new('COALESCE', [sum_function, 0], 'total_amount')</p>
<p>sql = et.project(et[Arel.star], aggregation)<br />
        .join(tt, Arel::Nodes::OuterJoin).on(et[:id].eq(tt[:envelope_id]))<br />
        .where(et[:user_id].eq(user_id))<br />
        .group(*envelopes_columns)<br />
        .order(et[:name]).to_sql</p>
<p>Envelope.find_by_sql(sql)<br />
[&#47;sourcecode]</p>
<p>There are a couple of tricks that I learned worth mentioning. The first one that appears in the code above is that you can get ARel to do any function supported in databases even if ARel doesn't natively understand it. Just use the NamedFunction class and pass in all the arguments for that function as an array. The 3rd argument is an optional alias. Even though <code>SUM()<&#47;code> is natively supported, I had to add it this way because it puts an alias in the wrong spot if I used the native way since I want the <code>SUM()<&#47;code> inside the <code>COALESCE()<&#47;code>. I want the <code>COALESCE()<&#47;code> because if it returns null, then I'll do another database query in my <code>total_amount<&#47;code> function.</p>
<p>The next trick is that you can do <code>et[Arel.star]<&#47;code> to generate <code>"Envelopes".*<&#47;code>. This is nice because the Envelopes table is quoted in the database-specific way (for sqlite here) and the splat is not quoted.</p>
<p>The last thing that if you want to use an outer join, just pass in the join class you want to use as a second parameter to the <code>join<&#47;code> method... easy!</p>
<p>That's it. This worked. (If you're wondering about the <code>*envelopes_columns<&#47;code> part, you need to go through <a href='http:&#47;&#47;tryruby.org'>Try Ruby<&#47;a>).</p>
<p>This actually met all of my initial priorities, but something didn't sit right with me. I didn't like how this query was not chainable like all of the other ActiveRecord queries. I can't use any of my other scopes with it. So, I went back to the ActiveRecord Query Interface and this time, I dug into the documentation more and looked through some Rails code. I found a way to make it all work using a combination of ActiveRecord and ARel.</p>
<p>[sourcecode language="ruby"]<br />
et = Envelope.arel_table<br />
tt = Transaction.arel_table</p>
<p>envelopes_columns = Envelope.column_names.map {|column_name| et[column_name.to_sym] }</p>
<p>sum_function = Arel::Nodes::NamedFunction.new('SUM', [tt[:amount]])<br />
aggregation = Arel::Nodes::NamedFunction.new('COALESCE', [sum_function, 0], 'total_amount')</p>
<p>select([et[Arel.star], aggregation])<br />
  .joins(Arel::Nodes::OuterJoin.new(tt, Arel::Nodes::On.new(et[:id].eq(tt[:envelope_id]))))<br />
  .group(envelopes_columns)<br />
[&#47;sourcecode]</p>
<p>I'm not going to explain all of this, but it's pretty cool that all of the ActiveRecord methods take ARel as parameters. Notice that the where clause is missing from this. That's because I moved it out into its own scope that I can chain on when I want. This also now uses my default scope which just specifies the order.</p>
<p>I think that this is great because it works with all my scopes and it's chainable and everything. I hope that this can be of some use to someone other than me. I learned a lot while trying to do this and I'm actually pretty surprised that it is all possible. I was half expecting to just have to use my string SQL query and leave it at that.</p>
